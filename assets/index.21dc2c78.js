var d=Object.defineProperty;var m=(l,e,t)=>e in l?d(l,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):l[e]=t;var a=(l,e,t)=>(m(l,typeof e!="symbol"?e+"":e,t),t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))s(o);new MutationObserver(o=>{for(const r of o)if(r.type==="childList")for(const n of r.addedNodes)n.tagName==="LINK"&&n.rel==="modulepreload"&&s(n)}).observe(document,{childList:!0,subtree:!0});function t(o){const r={};return o.integrity&&(r.integrity=o.integrity),o.referrerpolicy&&(r.referrerPolicy=o.referrerpolicy),o.crossorigin==="use-credentials"?r.credentials="include":o.crossorigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function s(o){if(o.ep)return;o.ep=!0;const r=t(o);fetch(o.href,r)}})();class c{constructor(e){a(this,"id");a(this,"hasWumpus");a(this,"hasHole");a(this,"hasBat");this.id=e,this.hasWumpus=!1,this.hasHole=!1,this.hasBat=!1}}class f{constructor(e,t,s=null){a(this,"arrowCount");a(this,"moveCount");a(this,"board",[]);a(this,"playerX",0);a(this,"playerY",0);a(this,"renderer");this.arrowCount=5,this.moveCount=0,this.generateGameboard(e,t),this.randomizePlayerPosition(),this.renderer=s,this.renderer!=null&&this.renderer.renderAll(this.board,this.playerX,this.playerY,this.arrowCount,this.moveCount)}randomizePlayerPosition(){for(;;){this.playerX=Math.round(Math.random()*(this.board.length-1)),this.playerY=Math.round(Math.random()*(this.board[0].length-1));const e=this.board[this.playerX][this.playerY];if(!e.hasWumpus&&!e.hasHole&&!e.hasBat)return}}movePlayer(e){let t=this.playerX,s=this.playerY;if(e==="North")s--,this.moveCount++;else if(e==="East")t++,this.moveCount++;else if(e==="South")s++,this.moveCount++;else if(e==="West")t--,this.moveCount++;else{console.log("Choose either North, East, South or West.");return}t===this.board.length?t=0:t===-1&&(t=this.board.length-1),s===this.board[0].length?s=0:s===-1&&(s=this.board[0].length-1),this.playerX=t,this.playerY=s,this.renderer!=null&&this.renderer.renderAll(this.board,this.playerX,this.playerY,this.arrowCount,this.moveCount)}wumpusPosition(){for(let e=0;e<this.board[0].length;e++)for(let t=0;t<this.board.length;t++)this.board[t][e].hasWumpus}moveWumpus(){for(let e=0;e<this.board[0].length;e++)for(let t=0;t<this.board.length;t++)if(this.board[t][e].hasWumpus){let s=t+1,o=e;s===this.board.length?s=0:o===this.board[0].length&&(o=0),console.log(t),console.log(e),this.board[t][e].hasWumpus=!1,this.board[s][o].hasWumpus=!0;return}}generateGameboard(e,t){if(e*t<20)throw new Error("The gameboard is too small! Choose a bigger one.");const s=[];for(let r=0;r<e;r++){const n=[];for(let i=0;i<t;i++){const u=new c(i*e+r+1);Math.random()<.2?u.hasHole=!0:Math.random()<.3&&(u.hasBat=!0),n.push(u)}s.push(n)}let o=0;for(let r=0;r<s[0].length;r++)for(let n=0;n<s.length;n++){const i=s[n][r];!i.hasHole&&!i.hasBat&&o++}if(o<2){console.log("bad room, trying again!"),this.generateGameboard(e,t);return}for(;;){const r=Math.round(Math.random()*(e-1)),n=Math.round(Math.random()*(t-1)),i=s[r][n];if(!i.hasHole&&!i.hasBat){i.hasWumpus=!0;break}}this.board=s}}class p{constructor(e,t,s){a(this,"boardContainer");a(this,"arrowContainer");a(this,"moveContainer");this.boardContainer=document.querySelector(e),this.arrowContainer=document.querySelector(t),this.moveContainer=document.querySelector(s)}renderBoard(e,t,s){let o="";for(let r=0;r<e[0].length;r++){o+="<tr>";for(let n=0;n<e.length;n++)t===n&&s===r?o+=`<td class="board-square"> ${e[n][r].id} <img src="/player.jpg" width="50"></td>`:e[n][r].hasWumpus?o+=`<td class="board-square"> ${e[n][r].id} <img src="/wumpus.png" width="50"></td>`:e[n][r].hasHole?o+=`<td class="board-square"> ${e[n][r].id} <img src="/hole.jpg" width="50"></td>`:e[n][r].hasBat?o+=`<td class="board-square"> ${e[n][r].id} <img src="/bats.jpg" width="50"></td>`:o+=`<td class="board-square"> ${e[n][r].id} </td>`;o+="</tr>"}this.boardContainer.innerHTML=o}renderArrows(e){this.arrowContainer.innerHTML=e.toString()}renderMoves(e){this.moveContainer.innerHTML=e.toString()}renderAll(e,t,s,o,r){this.renderBoard(e,t,s),this.renderArrows(o),this.renderMoves(r)}}const y=new p("#boardContainer","#arrows","#moves"),h=new f(5,4,y);setTimeout(()=>h.movePlayer("East"),1e3);setTimeout(()=>h.movePlayer("East"),2e3);setTimeout(()=>h.movePlayer("East"),3e3);console.log(h);
